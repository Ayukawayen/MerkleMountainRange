用Solidity實作了以[Merkle Mountain Range](https://github.com/nervosnetwork/merkle-mountain-range)儲存乙太坊Ropsten測試鏈上的Blockhash值的合約。

合約位址: [0xc2a290768fdd2f6afe727b39a558aed19b80028b](https://ropsten.etherscan.io/address/0xc2a290768fdd2f6afe727b39a558aed19b80028b)

程式碼: https://ropsten.etherscan.io/address/0xc2a290768fdd2f6afe727b39a558aed19b80028b#code

---------------------------

先簡單做了一個HTML UI: https://ayukawayen.github.io/MerkleMountainRange (建議在有裝Metamask的情況下連結)

![範例圖](https://i.imgur.com/LWDKB7q.png)

上圖所示，合約儲存了自Block#8467641起的865個Blockhash，分別儲存在5棵高度不同的Merkle Tree內，


從最久遠的區塊，也就是最下面一行看起，

Block#8467641至Block#8468152的512個區塊儲存在一棵高度為9的Full Merkle Tree，這棵Tree的Root(稱為Peak)是0x820541829a27d80340f8d3f025cab8cac717c1da41d30f7e72ce6922dde69963，

接下來的256個區塊儲存在高度8的Merkle Tree，再接下來的64個區塊儲存在高度6的Merkle Tree，再接下來的32個區塊儲存在高度5的Merkle Tree，

最上面一行則代表Block#8468505的Blockhash獨自儲存在一棵高度為0的Merkle Tree裡(其Peak就是Block#8468505的Blockhash)。



如果我們要證明最久遠的Block#8467641的Blockhash值，就針對此區塊所在的高度9的Merkle Tree產生Merkle Proof，也就是對應的9個節點的值，

在UI的blockNumber欄內填入任何範圍內的Blocknumber後按下[Generate Proof 1]可以執行以上流程。

以上的proof傳入合約的verify()函式後，合約依照merkle proof的驗證法，做9次hash後和儲存的Peak值0x820541829a27d80340f8d3f025cab8cac717c1da41d30f7e72ce6922dde69963比對便可做驗證。

---------------------------

大致的原理就是這樣。

我有一個程式會定期去更新合約狀態，因為合約內部可以取得最近256個區塊的Blockhash值，只要更新間隔沒有超過256個區塊，就能將新產生的Blockhash資訊持續存入Merkle Mountain Range結構裡。

有關狀態更新還有為什麼驗證時要傳localPeaks的部份下次再說明。
