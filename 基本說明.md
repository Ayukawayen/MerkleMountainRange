# 基本說明

用Solidity實作了以[Merkle Mountain Range](https://github.com/nervosnetwork/merkle-mountain-range)儲存乙太坊Ropsten測試鏈上的Blockhash值的合約。

合約位址: [0x8eD6e73612FC6E97b8cf4e1F2eCaB2d93e1Afd37](https://ropsten.etherscan.io/address/0x8eD6e73612FC6E97b8cf4e1F2eCaB2d93e1Afd37)

程式原始碼: https://ropsten.etherscan.io/address/0x8eD6e73612FC6E97b8cf4e1F2eCaB2d93e1Afd37#code

HTML UI: https://ayukawayen.github.io/MerkleMountainRange (建議在有裝Metamask的情況下開啟，Metamask要連到Ropsten測試鏈)

## 資料儲存與驗證

![範例圖](https://i.imgur.com/LWDKB7q.png)

以上圖為例，合約儲存了自Block#8467641起的865個Blockhash，分別儲存在5棵高度不同的Merkle Tree內。

從最久遠的區塊，也就是最下面一行看起，

Block#8467641至Block#8468152的512個區塊儲存在一棵高度為9的Full Merkle Tree，這棵Tree的Root(稱為Peak)是0x820541829a27d80340f8d3f025cab8cac717c1da41d30f7e72ce6922dde69963，

接下來的256個區塊儲存在高度8的Merkle Tree，

再接下來的64個區塊儲存在高度6的Merkle Tree，

再接下來的32個區塊儲存在高度5的Merkle Tree，

最上面一行則代表Block#8468505的Blockhash獨自儲存在一棵高度為0的Merkle Tree裡(其Peak就是Block#8468505的Blockhash)。


如果我們要證明最久遠的Block#8467641的Blockhash值，就針對此區塊所在的高度9的Merkle Tree產生Merkle Proof，也就是對應的9個節點的值。
在UI的blockNumber欄內填入任何範圍內的Blocknumber後按下[Generate Proof 1]可以執行以上流程。

將以上的proof傳入合約的verify()函式後，verify()函式依照Merkle Proof的驗證流程，做9次hash後和儲存的Peak值0x820541829a27d80340f8d3f025cab8cac717c1da41d30f7e72ce6922dde69963比對便可完成驗證。

## 合約狀態維護與Token機制

我有一個程式會定期傳送Transaction到合約位址，這個時候會呼叫到fallback function，以[Tx #0xe496d4324a72ab7f5999aa82893ec310cfd8dcdd7ab37c2b2361366ff8cbdc5e](https://ropsten.etherscan.io/tx/0xe496d4324a72ab7f5999aa82893ec310cfd8dcdd7ab37c2b2361366ff8cbdc5e)為例：

這個Tx被包在Block#8476270，在Tx執行之前，合約內的Merkle Mountain Range結構已經儲存了Block#8467641-Block#8476023的Blockhash資訊，
Tx會使用EVM內建的blockhash()函式讀取Block#8476024-Block#8476269的Blockhash值，用迴圈新增至Merkle Mountain Range結構，然後更新合約狀態。

這一次更新了246個Blockhash值，更新過程的gas用量是264394 (Tx的gas總用量是299407)。
我想說要給更新者(目前都是我)一些回報，就決定給跟gas用量相等的ERC20 Token，取名為MMR Token。

這過程有點像挖礦，更新者用ETH支付gas給礦工來維護合約狀態，並挖出MMR Token。
任何人都可以進行MMR Token的挖礦，只要向合約位址發送Transaction就好，Tx不需要輸入任何input data，但gas limit需要設高一點，推薦設為330000。(Metamask的預測會失準，因為Tx實際落入的區塊會更後面，因此迴圈執行次數會更多。)


MMR Token沒有收購價也沒有擔保品，就只是更新者花費了多少gas來幫助合約維護的一個證明而已。

接著我就想說，如果有其他合約來呼叫verify()做Blockhash的驗證的話，就收取MMR Token當手續費好了，這樣Token就有一些使用價值了，
因此針對上鏈的合約內部呼叫，每次驗證收取6000的MMR Token；
不上鏈的靜態呼叫不需要收(也收不到，而且能靜態呼叫的情況通常都可以直接查詢久遠區塊的Blockhash值，不需要傳入額外證明。)

為了避免出現需要驗證卻沒有辦法取得Token的情況，也可以直接使用ETH換取MMR Token。


## Bug Bounty

做為第一個應用例子，我放了一個合約在[0xfe60e44daa5acac4d0d6d63209287327691e9486](https://ropsten.etherscan.io/address/0xfe60e44daa5acac4d0d6d63209287327691e9486)，

如果有人能填入一個blockNumber和兩個不同的blockHash值，並填入適當的proof資訊，讓兩個不同的blockHash值的驗證都通過，就可以把合約裡的1.2個Ropsten ETH拿走(雖然Ropsten ETH只要去水龍頭拿就有了 XD)。

透過https://ropsten.etherscan.io/address/0xfe60e44daa5acac4d0d6d63209287327691e9486#writeContract 和合約互動，程式碼也可以在這邊看到。

兩次驗證需要12000個Token，你可以自己挖礦然後approve給合約#0xfe60e44daa5acac4d0d6d63209287327691e9486，然後呼叫challengeWithToken()；
或是呼叫challengeWithEth()並支付一些Ropsten ETH，合約會自行購買Token並找Ropsten ETH給你。

---------------------------

有關為什麼驗證時要傳localPeaks的部份下次再說明。
